[/
  Copyright 2008, 2016 Phil Bouchard
  Copyright 2016 Paul A. Bristow.

  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt
  or copy at http://www.boost.org/LICENSE_1_0.txt).
]

[article Boost.Root_ptr
    [quickbook 1.7]
    [copyright 2008, 2016 Phil Bouchard]
    [license
         Distributed under the Boost Software License, Version 1.0.
         (See accompanying file LICENSE_1_0.txt or copy at
         [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [id root_ptr] [/first item for all sub-sections]
    [authors [Bouchard, Phil] ]
    [/last-revision $Date: 2011-07-08 18:51:46 +0100 (Fri, 08 Jul 2011) $]
] [/article Boost.Block_pointer]

[warning This is NOT yet a Boost library and is subject to change and development.]

[caution This documentation is incomplete and subject to change.]

[import ../../../tools/auto_index/include/auto_index_helpers.qbk]
[/ auto_index_helpers.qbk MUST be FIRST included file!]

[/ If index enabled on the command line root_ptr\doc>b2 --enable-index --hash]
[/ then  --hash option is essential because names become too long.]
[/ Warning - the error message is entirely inscrutable!]

[import html4_symbols.qbk]

[/import ../example/root_ptr_snips.cpp -see example and other sections]

[template super[x]'''<superscript>'''[x]'''</superscript>''']
[template sub[x]'''<subscript>'''[x]'''</subscript>''']

[/ External links]
[def __cpp_standard [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4382.pdf C++ draft standard]]
[/Note that is just a convenient recent draft, not an actual standard.]

[def __boost_license [@http://www.boost.org/LICENSE_1_0.txt Boost License]]
[def __boostbook [@http://www.boost.org/doc/html/boostbook.html BoostBook]]
[def __boostbook_docs [@http://www.boost.org/doc/libs/release/doc/html/boostbook.html BoostBook documentation]]
[def __quickbook  [@http://www.boost.org/doc/tools/quickbook/index.html Quickbook]]
[def __quickbook_syntax [@http://www.boost.org/doc/libs/release/doc/html/quickbook/ref.html Quickbook Syntax Compendium]]
[def __docbook [@http://www.docbook.org/ DocBook]]
[def __doxygen [@http://www.doxygen.org/ Doxygen]]
[def __doxygen_conditionals [@http://www.stack.nl/~dimitri/doxygen/manual/commands.html#cmdcond Doxygen conditional command \cond ... \endcond]]
[def __pdf [@http://www.adobe.com/products/acrobat/adobepdf.html PDF]]
[def __inkscape [@http://www.inkscape.org Inkscape]]
[def __autoindex  [@http://www.boost.org/doc/libs/release/tools/auto_index/doc/html/index.html Automatic Indexing]]

[def __boost [@http://www.boost.org/ Boost]]
[def __boost_archives [@http://lists.boost.org/Archives/boost/ Boost archives]]
[def __boostroot [@boost: Boost root ./modular-boost]]
[def __boost_test [@boost:/libs/test/doc/html/index.html Boost.Test]]
[def __boost_timer [@boost:/libs/timer/doc/index.html Boost.Timer]]
[def __ADL [@http://en.cppreference.com/w/cpp/language/adl Argument Dependent Lookup (ADL)]]
[def __function_template_instantiation [@http://en.cppreference.com/w/cpp/language/function_template Function template instantiation]]
[def __fundamental_types [@http://en.cppreference.com/w/cpp/language/types fundamental]]
[def __edge [@https://en.wikipedia.org/wiki/Edge_case edge case]]
[def __corner [@https://en.wikipedia.org/wiki/Corner_case corner case]]
[def __boundary [@https://en.wikipedia.org/wiki/Boundary_case boundary case]]
[def __cmath [@http://en.cppreference.com/w/cpp/numeric/math C math]]
[def __is_fundamental [@http://en.cppreference.com/w/cpp/types/is_fundamental std::is_fundamental]]
[def __built-in [@http://en.cppreference.com/w/cpp/types/is_fundamental built-in]]
[def __fundamental  [@http://en.cppreference.com/w/cpp/types/is_fundamental fundamental]]
[def __is_arithmetic [@http://en.cppreference.com/w/cpp/types/is_arithmetic std::is_arithmetic]]
[def __is_floating_point[@http://en.cppreference.com/w/cpp/types/is_floating_point std::is_floating_point]]
[def __cardinal [@https://en.wikipedia.org/wiki/Cardinal_number cardinal]]
[def __radix [@https://en.wikipedia.org/wiki/Radix  radix]]
[def __garbage_collection [@https://en.wikipedia.org/wiki/Garbage_collection_(computer_science) garbage collection]]

[/Links to classes etc]

[/ depend on namespace layout]
[def __root_ptr [classref boost::root_ptr  root_ptr]]  [/TODO]
[/def __root_ptr_value_type [classref boost::root_ptr::root_ptr::value_type  value_type]]
[/def __root_ptr_float_type [classref boost::root_ptr::root_ptr::float_type  float_type]]

[/def __is_root_ptr [classref boost::root_ptr::is_root_ptr is_root_ptr]]

[/Links to sections within root_ptr]
[def __cppreference [@../html/boost_root_ptr_c___reference.html Boost root_ptr C++ Reference section]]
[def __examples [link root_ptr.examples examples]]
[def __intro [link root_ptr.intro introduction]]
[def __rationale [link root_ptr.design design rationale]]
[def __howtouse [link root_ptr.howtouse How to use this documentation]]

[/ Links to indexes]
[def __indexes [link root_ptr.indexes indexes]]
[def __index [link main_index Main Index]]
[def __class_index [link  class_index Class Index]]
[def __function_index [link function_index Function Index]]
[def __macro_index [link macro_index Macro Index]]

[section:intro Introduction]

Memory management can be subdivided in two categories:

* garbage collection .

* reference counting.

[/TODO these examples should be code snippets so we can be sure that they compile and run.]

[h3 Garbage Collection]

__garbage_collection is a technique where memory blocks are collected and later deallocated
when they are found to be unreferenced by any other object.

Garbage collection is used by many popular languages including:

* ML
* Haskell
* APL
* Lisp
* Ruby
* Java
* .NET (C#)?
* Smalltalk
* ECMAScript
* Sather

Garbage Collector Advantages are:

* Very fast allocation and deallocation timing.
* Dangling pointer bugs.
* Double free bugs.
* Certain kinds of memory leaks, leading over time to memory exhaustion.
* Possible to override system allocators without modifying any code

Garbage CollectorDisadvantage:

* Cannot reclaim memory or invoke finalizers / destructors block immediately.
* Cannot reclaim [*all] unreachable objects.
* Doesn't know which registers will be referenced.

An example of its usage is demonstrated here with the C/C++ implementation
of the popular [@https://en.wikipedia.org/wiki/Boehm_garbage_collector Hans Boehm garbage collector]:

``
  #include <gc.h>

  int main()
  {
      int * p = (int *) GC_MALLOC(sizeof(int) * 100); // Allocate an array of 100 integers.

      return 0;
  } // non-deterministic deallocation of the array.
``

Unfortunately this technique simply postpones the deallocation of the unreferenced objects
to later freeze the entire application, on a single CPU system,
and to collect them using various tracing algorithms.
This may be unacceptable for real-time applications or device driver implementation, for example.

For solar or battery-powered devices, the power consumed by garbage collection might also be significant.

[h3:reference_counting Reference Counting]

[import ../example/root_ptr_basic.cpp]

Reference counting is a different approach where objects pointed to
are aware of the number of times they are referenced.

This means a counter within the object is incremented or decremented
according to the number of smart pointers that are referencing or dereferencing it.

To demonstrate the destruction of no-longer-used objects, we can use a `struct`
that has a destructor that announces when it is called, for example:

[root_ptr_basic_A_noisy_death]

For example, using `boost::shared_ptr` (or the std:: version):

[root_ptr_basic_0]

[root_ptr_basic_S]

[root_ptr_basic_shared]

The main drawback is a lost in performance as compared to garbage collection
because of the extra time required to manage the counter every time
the pointer is reassigned or dereferenced.

Reference counting can also leave a group of blocks of memory referencing
each other (called "cyclic") unnoticed and therefore never freed by the application.

A cyclic set is shown here:

[root_ptr_basic_S]

[root_ptr_basic_shared_cylic]

The above example will never execute the call of the destructor of `struct A`
because the cycle will never get deallocated.
This is because the number of references will never reach 0.

A way to solve this problem is to isolate the location of the cycle,
which is this case is already known, and use a `weak_ptr` to break the cycle:

[root_ptr_basic_W]

[root_ptr_basic_weak_cylic]

The main drawback of this approach is the need to explicitly find
the cycle to later alter the code with respective `weak_ptr`s.

[h3:root_pointer Root Pointer]

Root Pointer is a memory manager on top of reference counting
and is also able to detect outright unreferenced cyclic blocks of memory.

Its performance is comparable to shared_ptr but is not requiring a bigger memory usage per pointer (2 times sizeof(void *)) for its associated node_ptr and (2 times sizeof(void *) + sizeof(node_proxy)) for root_ptr itself, given its ability to detect cyclic blocks of memory. 

For example:

``
  #include <iostream>
  #include <boost/smart_ptr/root_ptr.hpp>
  
  using namespace std;
  using namespace boost;

  struct A
  {
      node_ptr<A> p;
      
      A(node_proxy const & x) : p(x) 
      {
      }
      
      ~A()
      {
          cout << "~A()" << endl; // will get called
      }
  };
  
  int main()
  {
      root_ptr<A> x;
      x = make_root<A>(x);
      x->p = x;
      
      return 0;
  } // deterministic destruction
``

We can see in the above example that there is no need to manually find the location of the cycle.

[endsect] [/section:intro Introduction]

[section:rationale Rationale]

[h3:introduction Introduction]

Root Pointer introduces the concept of ['set] where it is defined to be a one or many memory blocks
referencing each other allocated on the heap pointed to by one or many `root_ptr<T>`s
allocated elsewhere by the application. Each ['set] is consequently composed of a list of all memory blocks
constituting it and a `node_proxy` linking each allocation and other potential `node_proxy`s.

For example:

[$/images/introduction.png   [align center] ]  [/ align centre does seem to work]

[h3:cyclism Cyclicism]

Therefore whenever a `node_proxy` contained within a `root_ptr<T>` is about to be destroyed,
the deallocation of each memory block composing the ['set] is enforced.
Thus whether the ['set] was composed of memory blocks referencing each other in a cyclic way or not,
all of them will be subject to destruction and deallocation
indifferent from the cyclicism problem presented by the reference counters.
As we can see in the following example, the `node_proxy` is destroyed and
consequently every elements composing the ['set] will be destructed and deallocated as well:

[$/images/cyclicism1.png]

[$/images/cyclicism2.png]

[h3:union Union]

A ['set] will be unified with another ['set]
whenever one of its member is found to reference a member from a different ['set].
Once two ['sets] are unified they will stay unified
even if the new reference responsible for unifying the ['sets] is once again disjointed.

[$/images/union1.png]

[$/images/union2.png]

[endsect] [/section:rationale Rationale]

[section:tutorial Tutorial]

[h3:basic Basic]

Root Pointer was designed to be easy to use and to be versatile in terms of object variants it can refer to.
Its only requirement is limited to the usage of a special type needed to instantiate objects referred to.

For example:

  root_ptr<int> p = make_root<int>(11);

will instantiate a special object 'node<int>' having an integer as one of its member.
The pointer to the object is then passed to the `root_ptr<int>` that will manage its existence
and later destroy and deallocate it when it is found to be no longer referenced.

The `root_ptr<int>` guarantees all associated allocations, cyclic or not, will be freed upon its destruction.
Once the root is defined, we can derive a `node_ptr<int>` from it:

  node_ptr<int> q = make_node<int>(p, 12);

A `node_ptr<int>` is an internal pointer in a set of objects that is compact
which uses the information of the associated `root_ptr<int>` to define its length of existence.
As its name suggests, this can be used, for example, as node pointers inside a container for a given root.

See [@../../example/root_ptr_example1.cpp root_ptr_example1.cpp]
for different cases of its usage.

[/TODO I think much more explanation would be helpful here?]

[import ../example/root_ptr_example1.cpp] [/for code snippets]

[h5:rvalue R-Value]

A function can be written to use as an R-value:

[root_ptr_example1_rvalue]

and called

[root_ptr_example1_rvalue_call]

to output [root_ptr_example1_output_rvalue]

[h5:slicing Slicing]

Slicing is shown in

[root_ptr_example1_slicing]

with output [root_ptr_example1_output_slicing]

[h5:sharing Sharing]

Sharing is shown in

[root_ptr_example1_sharing]

with output [root_ptr_example1_output_sharing]

[h3:advanced Advanced]

[h5:propagation Propagating node_proxy information]
A `root_ptr` derives from `node_proxy` and `node_ptr`.

You can propagate the information of the `node_proxy` by passing it as a [*reference]:

[root_ptr_example1_propagate]

[h5:cyclic_function Cyclic function]
In the case where a cyclic set is being destroyed,
in order to prevent `root_ptr`s member pointers from accessing an object
that has already been destroyed the function `cyclic()` is provided
to explicitly check the state of the pointee object:

[root_ptr_example1_cyclic]

[warning `cyclic` function should [*only be used in a destructor].]

[h5:faster_pointee Faster pointees]

Creating pointee objects in a faster way is possible by calling `make_fastroot`:

  root_ptr<int> p = make_fastroot<int>(10);

[h5:allocator Custom Allocator]
ou can actually use the allocator of your choice using the following function calls:

  root_ptr<int> p = allocate_node<int>(make_node_allocator<fast_pool_allocator, int>(), 12);

[h3:caveat Caveat]

Hierarchies with multiple inheritance without virtual tables will cause undefined behavior
if a pointer to a derived class is assigned to a pointer of one of its base class. For example:

  struct M { int i; };
  struct N { int i; };
  struct O : N, M { int i; };

  root_ptr<O> po = make_root<O>();
  root_ptr<N> pn = po; // Incorrect!
  root_ptr<M> pm = po; // Incorrect!

A way to bypass any problem that might be created by the example above is to add virtual destructors to the classes:

  struct M { int i; virtual ~M() {} };
  struct N { int i; virtual ~N() {} };
  struct O : N, M { int i; };

  root_ptr<O> po = make_root<O>();
  root_ptr<N> pn = po; // Correct.
  root_ptr<M> pm = po; // Correct.

[endsect] [/section:tutorial Tutorial]


[section:synopsis Synopsis]

For full details see the __root_ptr section in the __cppreference, noting especially
the items shown by color (and sometimes also in bold) are links which will usually provide
more details (generated from the Doxygen-syntax comments in the header files).

See also the __index, __class_index, __function_index and __macro_index.

(These indexes are automatically generated by Boost.Autoindex
from the Doxygen-syntax comments in the header and source files).

[section:headers Header File Structure]

[table Top level headers
[[Header][Contains]]
[[boost/root_ptr.hpp] [includes all other headers]]
[[boost/root_ptr/root_ptr.hpp] [includes just root_ptr headers]]
[[boost/root_ptr/root_ptr/allocator.hpp] [allocator type]]
] [/table Top level headers]

[table Implementation Headers
[[Header][Contains]]
[[boost/root_ptr/detail/root_ptr.hpp] [ implemention details]]
[[boost/root_ptr/detail/block_base.hpp] [ implemention details]]
[[boost/root_ptr/detail/root_ptr_base.hpp] [TODO]]
[[boost/root_ptr/detail/instrusive_list.hpp] [TODO]]
[[boost/root_ptr/detail/instrusive_stack.hpp] [TODO]]
[[boost/root_ptr/detail/system_pool.hpp] [system pool TODO]]
[[boost/root_ptr/detail/system_pool_spin.hpp] [system pool TODO]]
[[boost/root_ptr/detail/system_pool_gcc_x86.hpp] [system pool GCC x86 TODO]]
[[boost/root_ptr/detail/system_pool_w32.hpp] [system pool W32 TODO]]
]  [/table Implementation detail Headers]

[endsect] [/section:headers Header File Structure]

See __howtouse for more hints on how to find what you are looking for.

An overview of some features, notes,  warnings and tips follow.

[endsect] [/section:synposis Synposis]

[section:examples Examples]

[section:simple_example Example of a root_ptr type]

[/import ../example/root_ptr_example1.cpp already imported]

In order to use the root_ptr library, we first need an include:

[root_ptr_example1_include_1]

Output shows handling cyclism

[root_ptr_example1_output_1]

and the order of destruction:

[root_ptr_example1_output_2]

The full code is at  [@../../example/root_ptr_example1.cpp  root_ptr_example1.cpp].

[endsect] [/section:simple example Example of a root_ptr type]

[section:testing Testing]

See

The full code is at  [@../../test/root_ptr_test1.cpp  root_ptr_test1.cpp]

and  [@../../test/root_ptr_test3.cpp  root_ptr_test3.cpp]

[endsect] [/section:testing Testing]

[endsect] [/section:design Design, Implementation and Rationale]

[section:faq Frequently Asked Questions FAQ]
#['What compiler do I need?][br]
Support of many C++11 features is essential.
Visual Studio 2015 (version 14.0) is required.
Recent GCC and Clang compilers also work well.

[endsect] [/section:main_faq Frequently Asked Questions FAQ]

[section:howtouse How To Use This Documentation]

This documentation is prepared using the Boost __quickbook, __boostbook, __doxygen, __autoindex toolchain.

Start your search with the

* Table of Contents, but see also:

* Hyperlinks (shown in two colors depending on whether they have been visited, or not).[br]
Considerable work has been put into providing extensive links, so please use them!

* Indexes that link directly to both words in the text and to reference documentation.
Sometimes there are separate indexes for functions, class, macros, but often just one index.
These are automatically produced, so there is some 'clutter'.
If you know you are looking for a function, class or macro then a specific index will avoid most clutter.

* Doxygen-derived C++ Reference section.

[tip The colored class and function names are links will lead you to an individual class, function, or macro.
They are the key to finding what an item does,
and about its parameters, template parameters, pre and post conditions, and what they return.]

[tip Having found a class like `negatable`, use the find key to search for a specific function or value.
For example, using the index to search for `value_type` will lead you to the (long) page of
`class template negatable`, so then search for `value_type` and click on the link to get the detail.
This is much quicker than simply scrolling.]

The information given is derived from Doxygen-syntax comments in the include files, mainly
[@../../include/boost/smart_ptr/root_ptr.hpp root_ptr.hpp].

* Examples will often be your quickest way to find what you need to know.
Examples often deliberately use many features, often in a contrived fashion.
Snippets of syntax-colored code are used in the text.
You can also use links to display the entire source code of examples in the `example` folder.
You should be able to run these examples without modification
and are often a very good starting point to write your own code.

* Tests will also give examples of use. Like examples, there will be links to tests in the `test` folder.

[heading Admonishments]

[note These blocks typically go into more detail about an explanation given above.]

[tip These blocks contain information that you may find helpful while coding.]

[important These contain information that is imperative to understanding a concept.
Failure to follow suggestions in these blocks will probably result in undesired behavior.
Read all of these you find.]

[warning It is wise that you follow these. Failure to do so will lead to
incorrect, and very likely undesired, results.]

[h3:conventions Document Conventions]

This documentation aims to use of the following naming and formatting conventions:

* C++ code is in `root_ptr width font` and is syntax-highlighted in color, for example `double` in blue.
* Other code is in block [^teletype root_ptr-width font].
* Replaceable text that [*you will need to supply] is in [~italics].
* If a name refers to a free function, it is specified like this:
  `free_function()`; that is, it is in [^code font] and its name is followed by `()`
  to indicate that it is a free function.
* If a name refers to a class template, it is specified like this:
  `class_template<>`; that is, it is in [^code font] and its name is followed by `<>`
  to indicate that it is a class template.
* If a name refers to a function-like macro, it is specified like this: `MACRO()`;
  that is, it is uppercase in [^code font] and its name is followed by `()` to
  indicate that it is a function-like macro. Object-like macros appear without a
  trailing `()` and are often used to control options by being defined, perhaps with a specific value.
* Names that refer to ['concepts] in the generic programming sense
(like template parameter names) are specified in CamelCase, for example [^IntegralRange].

To find what you are looking for try:

* Details of all classes, functions, parameters,  and template parameters are provided in the  __cppreference.
* See the __indexes and click on links colored to show that they are links.
* See __indexes, and separate __class_index, __function_index, __macro_index.

[endsect] [/section:howtouse How To Use This Documentation]

[section:map Roadmap]

[h4 1.?]

* First Release.
[h4 Post review changes]

[h4 Pre-review history]

[h4 Pre-Review Comments]


[endsect] [/section:map Roadmap]

[section:history Historial discussions]
 TODO?


[endsect] [/section:history Historial discussions]

[section:ack Acknowledgements, Thanks and Credits]

This library would not have happened without:

Thanks for Steven Watanabe, John Maddock, Peter Dimov, David Abraham, Rob Stewart, Mathias Gaunard, Frank Mori Hess,
Emil Dotchevski, Glen Fernandes
and Paul A. Bristow for a test template, suggestions, directions and documentation.

[endsect] [/section:ack Acknowledgements]

[section:references References]

# [@http://www-cs-faculty.stanford.edu/~uno/taocp.html "The Art Of Computer Programming"],
Donald E. Knuth, Volume 2: Seminumerical Algorithms, Third Edition
(Reading, Massachusetts: Addison-Wesley, 1997), xiv+762pp. ISBN 0-201-89684-2

[/todo Need more background references?]

#__n1169

[endsect] [/section:ack References]

[/link xml.autodoc C++ reference doesn't work]

[xinclude autodoc.xml] [/ Using Doxygen generated C++ reference documentation.]

[/Only want this if index enabled on the command line like root_ptr\doc>b2 --enable-index --hash]
[section:indexes Indexes]

[#main_index]
[/Complete index]
[/'''<index/>''' can now be written as ]
[index]

[/Separate type indexes]
[/ modular-boost/tools/auto_index/doc/html/index.html Boost autoindex ]
[/named_index type title] [/see modular-boost/tools/auto_index/doc/autoindex/qbk.html]
[#function_index]
[named_index function_name Function Index]
[#class_index]
[named_index class_name Class Index]
[#macro_index]
[named_index macro_name Macro Index]
[endsect] [/section:indexes Indexes]





